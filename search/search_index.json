{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"A typed, combinator-based, functional smart contract language without loops or recursion, designed for Bitcoin-like blockchains.\"","text":""},{"location":"#key-features","title":"Key Features","text":""},{"location":"#expressive-smart-contracts","title":"Expressive Smart Contracts","text":"<p>Simplicity allows developers to write contracts that go beyond the limitations of Bitcoin Script. Complex financial workflows, conditional payments, and tokenized assets can all be encoded efficiently and safely.</p>"},{"location":"#predictable-resource-usage","title":"Predictable Resource Usage","text":"<p>Every Simplicity contract has clearly bounded computational costs. This ensures contracts run reliably on-chain without unexpected fees or execution failures.</p>"},{"location":"#formally-specified","title":"Formally Specified","text":"<p>Simplicity smart contracts can be formally specified using mathematical proof assistants, enabling rigorous verification of their behavior. This ensures that contracts behave exactly as intended, significantly reducing the risk of critical bugs and security vulnerabilities.</p>"},{"location":"#enhanced-security","title":"Enhanced Security","text":"<p>Contracts are designed to behave exactly as written, reducing the risk of bugs or unintended outcomes. Users and institutions can trust that their rules and conditions will be enforced correctly.</p>"},{"location":"#seamless-bitcoin-and-liquid-integration","title":"Seamless Bitcoin and Liquid Integration","text":"<p>Simplicity is built for Bitcoin-style blockchains and Liquid, making it easy to integrate with existing blockchain infrastructure. Tokenized assets, settlements, and decentralized finance workflows can leverage its native compatibility.</p>"},{"location":"#support-for-conditional-logic","title":"Support for Conditional Logic","text":"<p>Developers can encode conditional payments, options, and automated triggers directly into contracts. This enables more sophisticated financial products without relying on external intermediaries.</p>"},{"location":"#compact-and-efficient-design","title":"Compact and Efficient Design","text":"<p>Contracts are optimized for on-chain execution, keeping size and operational overhead minimal. This allows for faster transaction processing and reduced blockchain load.</p>"},{"location":"#compatibility-with-multi-party-workflows","title":"Compatibility with Multi-Party Workflows","text":"<p>Simplicity can handle multi-party agreements, such as escrow-free marketplaces or collaborative finance operations. Parties can interact securely without giving up control to a central authority.</p>"},{"location":"#example","title":"Example","text":"<p>A basic pay-to-pubkey SimplicityHL program looks like this:</p> <pre><code>fn main(pubkey: Pubkey, funds: Funds) -&gt; Funds {\n    let (witness = _, funds) = commit(\n        Witness = ValidSignature(pubkey, funds),\n        funds,\n    );\n    funds\n}\n</code></pre> <p>This compiles to Simplicity combinators that can be formally verified and executed on-chain.</p>"},{"location":"documentation/","title":"Index","text":""},{"location":"documentation/#simplicity-documentation-overview","title":"Simplicity Documentation Overview","text":"<p>This folder contains key resources for understanding and developing with Simplicity. Below is a summary of each file and its purpose:</p> <p>include delving posts</p> <p>include sankeets example</p>"},{"location":"documentation/#how-simplicity-worksmd","title":"how-simplicity-works.md","text":"<p>Explains the fundamentals of Simplicity, its combinator-based design, and the role of jets in optimizing smart contract execution. Includes a diagram of the compilation and validation process.</p>"},{"location":"documentation/#jets-explainedmd","title":"jets-explained.md","text":"<p>Provides a deep dive into jets: what they are, why they're important, and the multi-stage process for creating, verifying, and deploying jets in Simplicity. Covers formal verification and consensus safety.</p>"},{"location":"documentation/#simplicity-comparedmd","title":"simplicity-compared.md","text":"<p>Compares Simplicity to other blockchain scripting languages (Bitcoin Script, Miniscript, Solidity) across expressiveness, execution model, safety, verification, and more. Useful for understanding Simplicity's unique advantages.</p>"},{"location":"documentation/#simplicity-for-evm-developersmd","title":"simplicity-for-evm-developers.md","text":"<p>Guides developers familiar with Ethereum/Solidity on how to adapt to Simplicity's UTXO-based, non-Turing-complete model. Includes a migration tips table and a video introduction.</p> <p>Use these files as starting points for learning, reference, and onboarding. For deeper technical details, see the SimplicityHL and Haskell guides in the <code>getting-started/</code> folder.</p>"},{"location":"documentation/how-simplicity-works/","title":"How Simplicty works","text":"<p>Simplicity is a typed, combinator-based, functional smart contract language without loops or recursion, designed as a more powerful and analyzable alternative to Bitcoin Script. Developers write contracts in human-readable, Rust-like SimplicityHL, which compiles into the core Simplicity representation.</p> <p>Frequently used operations are implemented as jets. Jets are predefined, highly efficient building blocks, allowing contracts to execute complex conditional payments, options, and multi-party transactions with predictable resource usage and no reliance on a central authority.</p> <p>Let's delve deeper into how Simplicity works within the Bitcoin ecosystem:</p>"},{"location":"documentation/how-simplicity-works/#simplicityhl-compilation-and-simplicity-bytecode","title":"SimplicityHL Compilation and Simplicity Bytecode","text":"<p>SimplicityHL is a developer-friendly front-end language, engineered to simplify the process of writing smart contracts by offering a syntax akin to the Rust programming language. It effectively abstracts away the intricate, low-level functional programming details inherent in raw Simplicity. The SimplicityHL Compiler is the dedicated toolchain responsible for translating SimplicityHL code into its foundational Simplicity representation. This approach is crucial because, while Simplicity offers profound mathematical expressiveness, its low-level nature means that practically, developers will write in higher-level languages that then compile down to Simplicity, complete with formal proofs of their correct operation.</p> <p>The resulting Simplicity binary format, often colloquially referred to as \"bytecode,\" is distinctly not traditional machine code and operates fundamentally differently from byte-aligned systems. Instead, it is a canonicalised representation of the program's abstract syntax tree (AST). Simplicity itself is a low-level, typed, combinator-based functional programming language and machine model designed specifically for blockchain-based smart contracts, operating directly on bit strings rather than bytes.</p> <p>This bit-oriented approach is a deliberate and crucial design choice, optimising for the unique constraints of blockchain environments. Simplicity programs are structured as Directed Acyclic Graphs (DAGs), which are topologically sorted lists of nodes representing untyped expressions with explicit sharing of subexpressions. This DAG structure is then serialised using a highly efficient binary prefix code. This bit-level packing maximises compactness, minimises bandwidth and storage requirements, and plays a vital role in preventing denial-of-service attacks and transaction malleability by ensuring precise consumption of witness data. For instance, the <code>inflate</code> function, which decodes bit strings into Simplicity values, fails unless it consumes exactly all of its bit string argument. This precision means there's no room for unused padding that could otherwise be exploited.</p> <p>When this binary format is loaded into the Bit Machine, Simplicity's abstract interpreter, it meticulously reconstructs the syntax tree for evaluation. This process is more accurately described as \"assembling\" a Simplicity tree rather than traditional compilation, as it bypasses the complex optimisations typically associated with compilers. The Bit Machine itself operates on values represented as arrays of cells, where each cell can be a <code>0</code>, <code>1</code>, or an <code>undefined</code> value, further underscoring the system's fundamental bit-level granularity. This design ensures predictable and formally verifiable resource usage, a cornerstone of Simplicity's high-assurance smart contract capabilities.</p>"},{"location":"documentation/how-simplicity-works/#contract-storage-and-integration-in-taproot","title":"Contract Storage and Integration in Taproot","text":"<p>Simplicity contracts are designed to integrate seamlessly into Bitcoin via Taproot's tapleaf versioning system. This allows for a flexible blend of Simplicity scripts with existing Bitcoin Script or standard Taproot key-spend paths within the same transaction.</p> <p>Specifically, a Simplicity program is committed to a commitment Merkle root, which is a hash of its syntax tree. This Merkle root is what gets stored on-chain, not the full script. This leverages the Merklized Abstract Syntax Trees (MASTs) principle, where programs are organised into trees, and only the necessary branches are revealed at redemption time, significantly enhancing privacy and reducing block space requirements. Just as with Bitcoin's Pay-to-Script-Hash (P2SH), where only a script's hash is committed initially and the full script is revealed when funds are redeemed, Simplicity adopts this efficient and private model.</p>"},{"location":"documentation/how-simplicity-works/#broadcasting-to-the-mempool-and-running-alongside-bitcoin-transactions","title":"Broadcasting to the Mempool and Running Alongside Bitcoin Transactions","text":"<p>When a transaction contains a Simplicity program (or more precisely, its commitment Merkle root within a Taproot output), it is broadcast to the mempool just like any other Bitcoin transaction. The transaction's validity, including the Simplicity component, is verified by network nodes according to the consensus rules. A Simplicity program is defined as an expression with trivial input and output values (type <code>1-&gt;1</code>), and its semantics determine whether the provided witness data authorises the redemption of funds for a specific transaction input.</p> <p>This design allows Simplicity to run alongside traditional Bitcoin transactions. By integrating via Taproot's tapleaf versions, a single transaction can incorporate outputs controlled by conventional Bitcoin Script, Taproot key-spends, and Simplicity scripts. This means Bitcoin continues to function as programmable money, with Simplicity extending its capabilities beyond the limitations of original Bitcoin Script, without requiring a separate blockchain. It simply augments the existing, robust infrastructure.</p>"},{"location":"documentation/how-simplicity-works/#versioning-for-simplicity-upgrades","title":"Versioning for Simplicity Upgrades","text":"<p>The integration of Simplicity leverages Taproot's tapleaf versioning system for managing upgrades and introducing new functionalities. Taproot allows each script path in a Merkle tree to have its own version number. When a leaf within a Taproot tree is spent, if it carries a specific Simplicity version number, the network will invoke the Simplicity runtime instead of the standard Bitcoin Script runtime. This offers far greater flexibility compared to older Bitcoin scripting versions.</p> <p>This versioning mechanism also supports the evolution of Simplicity's underlying components. For example, if there are significant improvements to cryptographic libraries, new versions of Simplicity jets can be substituted through this system. While introducing new jets might necessitate a soft fork, Simplicity's inherent expressiveness, combined with a comprehensive library of existing jets and combinators, aims to minimise the need for frequent soft forks by enabling a vast range of applications without requiring changes to the core language.</p>"},{"location":"documentation/how-simplicity-works/#jets-and-their-weight-calculation","title":"Jets and Their Weight Calculation","text":"<p>Jets are optimised native code implementations that act as \"shortcuts\" for large, complex Simplicity expressions, significantly compressing their representation and execution footprint. These native implementations are formally proven to be functionally identical to the more verbose Simplicity expressions they replace. Examples of jets include common cryptographic functions like SHA-256 compression and Schnorr signature verification, as well as various arithmetic and introspection operations.</p> <p>Examples of jets include:</p> <ul> <li> <p>Cryptographic functions: These are crucial for secure smart contracts. Specific examples include the SHA-256 compression function and Schnorr signature verification (BIP-340). Other elliptic curve functions for <code>secp256k1</code> are also included, such as point verification, scalar arithmetic, and field element operations.</p> </li> <li> <p>Arithmetic operations: Simplicity includes jets for various arithmetic functions, such as 32-bit addition, subtraction, and multiplication. General multi-bit logic operations like complement, <code>and``,</code>or<code>, and</code>xor` are also implemented as jets</p> </li> <li> <p>Introspection operations: These allow smart contracts to examine transaction data. Examples include <code>script-cmr</code> (script commitment Merkle root), <code>internal-key</code>, <code>version</code>, <code>lock-time</code>, <code>output-value</code>, <code>input-value</code>, <code>tapleaf-version</code>, and <code>tappath</code>.</p> </li> <li> <p>Time locks: Jets exist for various time-based conditions like <code>check-lock-height</code>, <code>check-lock-time</code>, <code>tx-height-lock</code>, <code>tx-time-lock</code>, <code>tx-distance-lock</code>, and <code>tx-duration-lock</code>, which assert conditions based on block height or time.</p> </li> <li> <p>Elements-specific jets: For the Liquid Network, Simplicity includes additional jets related to Elements features such as issuances, assets, amounts, range proofs, and surjection proofs.</p> </li> </ul> <p>The weight (similar in spirit to Bitcoin\u2019s vbytes, but tied to computational and memory usage) of a Simplicity program, including its jets, is calculated using static analysis before execution. This crucial feature enables users to determine the maximum computational resources (CPU time and memory) a program will require, even for worst-case scenarios. This pre-computation capability is a fundamental defence against denial-of-service attacks, as transactions with excessively costly scripts can be rejected early.</p> <p>Simplicity employs a fine-grained cost function that allows for precisely calibrated fees based on the actual resources consumed, balancing affordability for legitimate use with disincentives for network abuse. There are two categories of jets:</p> <ol> <li> <p>Ordinary jets: Handled locally by implementations.</p> </li> <li> <p>Discounted jets: These receive special treatment under consensus rules, with explicitly defined cost overrides that are determined through benchmarking, rather than being calculated solely by the Bit Machine's default rules.</p> </li> </ol> <p>This mechanism ensures that highly efficient native code implementations (jets) are correctly accounted for, making complex smart contracts economically viable and predictable for Bitcoin's robust, long-term infrastructure. Simplicity thus empowers builders with unprecedented security and flexibility, solidifying Bitcoin's role as a foundation for a resilient, censorship-resistant financial future.</p> <pre><code>flowchart TD\n    A[SimplicityHL Code] --&gt; B[Compile to Simplicity]\n    B --&gt; C{Need Optimization?}\n    C --&gt;|Yes| D[Apply Jets]\n    C --&gt;|No| E[Pure Simplicity]\n    D --&gt; F[Execute on Blockchain]\n    E --&gt; F\n    F --&gt; G{Validation Success?}\n    G --&gt;|No| H[Transaction Rejected]\n    G --&gt;|Yes| I[UTXO Updated]</code></pre>"},{"location":"documentation/jets-explained/","title":"What's a Jet?","text":"<p>A Jet in Simplicity is a pre-defined, highly optimized function, usually written in C, that can replace a more general (and slower) Simplicity expression.</p> <p>This process accelerates computation without changing the underlying meaning, which is crucial for blockchain performance.</p> <p>Think of a Jet as a shortcut:</p> <ul> <li> <p>Without Jets: Simplicity executes everything step by step using combinators (correct but slow).</p> </li> <li> <p>With Jets: the same logic runs much faster, but the result is provably identical.</p> </li> </ul>"},{"location":"documentation/jets-explained/#why-are-jets-important","title":"Why are Jets Important?","text":"<ul> <li> <p>Performance: Blockchain validation must be fast. Jets dramatically reduce computation time.</p> </li> <li> <p>Security: Each Jet is rigorously specified and formally proven to behave exactly like its Simplicity equivalent.</p> </li> <li> <p>Consensus Safety: Jets have fixed, predictable costs to prevent denial-of-service attacks.</p> </li> <li> <p>Scalability: More complex smart contracts become feasible without compromising verification speed.</p> </li> </ul>"},{"location":"documentation/jets-explained/#jet-creation-process","title":"Jet Creation Process","text":"<p>The development of a Jet follows a rigorous, multi-stage pipeline to ensure its correctness and safety.</p>"},{"location":"documentation/jets-explained/#1-prototyping-with-simplicity-combinators","title":"1. Prototyping with Simplicity Combinators","text":"<p>The initial phase involves building the desired functionality using only the fundamental building blocks (combinators) of Simplicity.</p> <p>This serves as a high-level, human-readable blueprint.</p>"},{"location":"documentation/jets-explained/#2-formal-specification","title":"2. Formal Specification","text":"<p>The Jet's behavior is described with mathematical precision in Rocq/Coq.</p> <p>This specification is the \u201csource of truth\u201d against which all implementations (C, Haskell, Rust) are verified.</p>"},{"location":"documentation/jets-explained/#3-haskell-implementation","title":"3. Haskell Implementation","text":"<p>A reference implementation is written in Haskell, a functional programming language.</p> <p>This version is easier to reason about and serves as an intermediate step before low-level coding.</p>"},{"location":"documentation/jets-explained/#4-optimised-native-code-implementation","title":"4. Optimised Native Code Implementation","text":"<p>A highly efficient version of the Jet is coded in C.</p> <p>This is the implementation that will be executed by the Liquid or Bitcoin client for maximum performance.</p>"},{"location":"documentation/jets-explained/#5-benchmarking-and-costing-for-consensus","title":"5. Benchmarking and Costing for Consensus","text":"<p>The computational resources (CPU time, memory) required by the C implementation are measured precisely.</p> <p>This data is used to assign a fixed cost/weight to the Jet for consensus rules, preventing denial-of-service attacks.</p>"},{"location":"documentation/jets-explained/#6-formal-proof-of-equivalence","title":"6. Formal Proof of Equivalence","text":"<p>Using a proof assistant like Coq, a formal, machine-checked proof is constructed.</p> <p>This proves that the optimized C implementation is semantically identical to the formal specification.</p>"},{"location":"documentation/jets-explained/#7-integration-and-standardisation","title":"7. Integration and Standardisation","text":"<p>Once fully verified and benchmarked, the Jet is integrated into the core Simplicity library and considered for standardization, making it available for general use in Liquid and Bitcoin scripts.</p>"},{"location":"documentation/jets-explained/#8-deployment","title":"8. Deployment","text":"<p>Newer Jets are deployed to a Bitcoin testnet for real-world testing.</p>"},{"location":"documentation/simplicity-compared/","title":"Simplicity Compared","text":"<p>Simplicity was designed from the ground up to address the limitations of existing blockchain scripting languages while maintaining the security guarantees that make Bitcoin reliable.</p> Bitcoin Script Miniscript Solidity Simplicity Comments Primary purpose Minimal spend conditions for Bitcoin UTXOs Safer, structured way to write Bitcoin Script policies General-purpose smart contracts on Ethereum-like blockchains Formally verifiable contracts in Bitcoin-like settings Expressiveness Limited by design More composable than Bitcoin script Very high High within strict rules More features enable richer apps but can introduce more ways to make mistakes. Execution model Stack-based, no global state Policy \u2192 Script, tree-structured, Stack-based. Runs on EVM with global state Combinator-based, no loops/state Affects fees, speed, and how contracts interact. Simpler execution models are easier to reason about and audit. Turing-completeness No No Yes No Non\u2013Turing-complete means predictability: no endless loops and easier to know scripts finish quickly. Gas is less relevant; execution time is bounded. Typical use cases Payments, multisig, timelocks Advanced wallet policies, thresholds with fallbacks DeFi, tokens, DAOs, dApps High-assurance financial logic on Liquid Guides what each is good for so solutions aren't overbuilt or underpowered. Safety approach Minimal opcodes, deterministic Constrained grammar + static checks Security via patterns, audits, tooling Designed for formal proofs and determinism Tells how each reduces bugs and protects funds. Simpler rules = fewer surprises. State model UTXO (local) UTXO (via Script) Account/global state UTXO-style Local (UTXO) limits blast radius; global state enables composability but can spread risk. Formal verification Limited Better static analysis Possible but complex Core feature Strong guarantees lower the chance of catastrophic bugs and costly exploits. Performance/resource bounds Bounded by consensus Bounded by consensus Gas-limited execution Strict bounds Predictable costs and low DoS risk make fees and UX more stable. Interoperability Bitcoin-native Bitcoin-native EVM-wide standards Liquid ecosystem Affects integrations and network effects for adoption."},{"location":"documentation/simplicity-for-evm-developers/","title":"Simplicity for EVM Developers","text":"<p>Michael from Boltz explaining EVM and Liquid differences</p> <p>Welcome, Solidity and EVM developers! You're used to a world of account-based models, Turing-complete languages, and sophisticated state management.</p> <p>Simplicity, a new programming language from Blockstream Research, offers a fundamentally different approach, bringing high-assurance smart contracting to Bitcoin-style UTXO-based blockchains like Liquid.</p> <p>While it operates on different principles, Simplicity aims to provide expressiveness without sacrificing reliability. Its design allows you to build sophisticated smart contracts and be confident in their outcomes.</p> <p>This guide will help you navigate the key conceptual shifts as you transition into the Simplicity world.</p>"},{"location":"documentation/simplicity-for-evm-developers/#key-differences-simplicity-vs-evmsolidity","title":"Key Differences: Simplicity vs. EVM/Solidity","text":"Aspect Simplicity (UTXO) EVM / Solidity (Account) Practical Migration Tip State Model UTXO-based Account-based Replace global variables with UTXOs carrying contract data. To update state, consume the old UTXO and create a new one with the new state. Language Simplicity (low-level, combinator-based) Solidity (high-level, imperative) Simplicity programs are pure, side-effect-free functions. Build logic by composing small operations instead of writing imperative code. Shift from \u201cwriting instructions\u201d to \u201cconnecting transformations.\u201d Turing Completeness No (bounded programs only) Yes (limited by gas) Rewrite loops as fixed-size unrolled logic; precompute where possible. Persistence Stateless; data in UTXOs only Contracts have permanent storage Store state as commitments inside UTXOs. Carry forward data explicitly via transactions. Smart Contract Calls No native inter-contract calls Inter-contract calls, libraries Use transaction chaining to compose logic; each step handled by a different UTXO. Gas Model Static resource bounds Runtime gas estimation Bounds (e.g. bit usage) are known at compile time \u2192 predictability. Determinism Fully deterministic Some non-deterministic values (<code>block.timestamp</code>) Use pre-committed data and covenant-based enforcement. Security Model No shared state; no reentrancy Reentrancy, shared mutable state No need for reentrancy guards; logic is isolated by design. Verification Built-in formal verification support Optional, often post-hoc Simplicity enables formal proofs of behavior upfront. Deployment Commit code hashes only Deploy full code on-chain Prepare full expressions off-chain; deploy only program commitments. Data Input/Output All inputs explicit Calldata, storage reads Define inputs/outputs clearly; all data must come via inputs/UTXOs. Oracles Pre-committed or covenant-enforced Chainlink &amp; external calls Use pre-signed data or UTXO conditions for oracle inputs. <p>Simplicity and EVM differences</p>"},{"location":"documentation/simplicity-for-evm-developers/#simplicity-is-so-simple-it-fits-on-a-t-shirt-does-that-mean-its-as-limited-as-bitcoin-script","title":"Simplicity is so simple it fits on a T-shirt. Does that mean it's as limited as Bitcoin Script?","text":"<p>Absolutely not. While a complete description of Simplicity's core language does fit on a T-shirt, this simplicity refers to its foundational design and formal semantics, not its expressiveness.</p> <p>Unlike Bitcoin Script, which is limited by design and lacks expressiveness for complex smart contracts, Simplicity aims to provide complete expressiveness for whatever computations you need. It is finitarily complete, meaning it can program all finite computations required for a powerful smart contract system. You can even verify Turing-complete off-chain computations on the main chain using Simplicity.</p>"},{"location":"documentation/simplicity-for-evm-developers/#is-simplicity-turing-complete-like-evm","title":"Is Simplicity Turing-complete like EVM?","text":"<p>No, Simplicity is intentionally Turing-incomplete. This is a crucial design choice that sets it apart from languages like EVM. The reason for this is to enable static analysis.</p> <p>Why Turing-incompleteness is a feature in Simplicity:</p> <ul> <li>Predictable Resource Costs: It allows you to determine how much any Simplicity program will cost to run before you stake your money on it. This prevents programs from consuming excessive memory or computation time, safeguarding against denial-of-service attacks. This contrasts with Ethereum's \"out of gas\" issues, where pre-paid fees can be lost if a program runs out of gas unexpectedly.  </li> <li>Guaranteed Termination: By disallowing unbounded loops and recursion, Simplicity ensures that all programs terminate. Bounded loops are achieved by unrolling the loop, with sub-expression sharing preventing unreasonable impacts on program size.  </li> <li>Enhanced Verifiability: The lack of Turing completeness contributes to the language's simplicity and analyzability, making it amenable to formal reasoning.</li> </ul>"},{"location":"documentation/simplicity-for-evm-developers/#how-does-simplicity-handle-state-or-does-it-have-a-global-state-like-ethereum","title":"How does Simplicity handle state, or does it have a global state like Ethereum?","text":"<p>Unlike EVM contracts that can access key-value data stores to maintain state across transactions, Simplicity has no state. Simplicity is a purely functional, expression-based language. Every Simplicity expression fundamentally denotes a function mapping input values to output values. It cannot directly express values; instead, it expresses constant functions that always produce the same output.</p> <p>Simplicity operates within the Bitcoin UTXO (Unspent Transaction Output) model. In this model, funds are controlled by small programs. When you spend coins, you essentially provide evidence (witness data) that the program guarding those funds evaluates to true, allowing the transaction to proceed.</p>"},{"location":"documentation/simplicity-for-evm-developers/#how-do-i-prove-my-simplicity-contract-is-correct-do-i-write-proofs-in-simplicity-itself","title":"How do I prove my Simplicity contract is correct? Do I write proofs in Simplicity itself?","text":"<p>You do not perform formal proofs in Haskell or Simplicity directly. Simplicity's formal specification and verification of its core language and semantics take place in the Coq proof assistant.</p> <p>The proof process works as follows:</p> <ul> <li> <p>Simplicity's semantics have a precise mathematical model defined in Coq, which allows for rigorous proofs of correctness.</p> </li> <li> <p>You can directly prove correctness properties about your specific smart contract written in Simplicity using formal methods within the Coq framework. This means you can formally verify every step.  </p> </li> <li> <p>This approach empowers users to create formal proofs of correctness for their smart contracts before deployment, addressing the immutability problem of blockchain smart contracts where mistakes cannot be corrected once deployed. For instance, you can prove that coins cannot be moved without a specific signature, or that a program won't exceed a memory threshold.  </p> </li> <li> <p>The Haskell implementation is primarily used for constructing and prototyping Simplicity programs. These programs are then the subject of formal proofs conducted in Coq. There is no formalized connection between the Haskell library and Simplicity's formal semantics in Coq, so the Haskell library is intended for experimental development, not production where formal proofs are critical.</p> </li> </ul>"},{"location":"documentation/simplicity-for-evm-developers/#simplicity-is-a-low-level-language-will-i-be-writing-contracts-directly-in-it-or-is-there-a-higher-level-abstraction","title":"Simplicity is a low-level language. Will I be writing contracts directly in it, or is there a higher-level abstraction?","text":"<p>While Simplicity is an extremely low-level language, akin to assembler, you are not expected to write contracts directly in it for most applications.</p> <p>Higher-level languages and tools are available:</p> <ul> <li> <p>SimplicityHL: This is a developer-friendly \"front-end\" language that compiles down to Simplicity assembly. It has a syntax similar to Rust, abstracting away some of Simplicity's functional programming details to make it more accessible.</p> </li> <li> <p>SimplicityHL web-IDE: You can start experimenting with Simfony using the web IDE, which includes example programs.</p> </li> <li> <p>Haskell Implementation: This provides a way to construct Simplicity programs in a tagless-final style, which transparently handles sharing of subexpressions. The <code>Haskell-Examples</code> folder in the Simplicity repository contains various Simplicity expressions written in Haskell.  </p> </li> <li> <p>Future Higher-Level Languages: The ultimate vision is for users to write contracts in various higher-level languages that then compile down to Simplicity code alongside proofs of their correct operation.</p> </li> </ul>"},{"location":"documentation/simplicity-for-evm-developers/#what-are-jets-and-how-do-they-make-complex-operations-efficient","title":"What are 'Jets' and how do they make complex operations efficient?","text":"<p>Jets are a key concept for efficiency and extensibility in Simplicity.</p> <ul> <li> <p>A jet is a single combinator that replaces a larger Simplicity expression, known as its \"specification\".  </p> </li> <li> <p>While the core Simplicity language is concise, complex programs built solely from its basic combinators could be kilobytes of code and take minutes to execute.  </p> </li> <li> <p>Jets solve this by allowing the Simplicity interpreter to evaluate the jet either by evaluating its Simplicity specification or by using optimized machine code (often C implementations) that has the same effect.  </p> </li> <li> <p>Crucially, these optimised implementations are formally proven equivalent to their Simplicity specifications in Coq. For example, the SHA-256 compression function and libsecp256k1 elliptic curve operations have been reimplemented and formally verified in Simplicity.  </p> </li> <li> <p>This approach opens a clear path for introducing new features and optimisations without constant soft forks. Simplicity's comprehensive \"catalog of jets\" includes cryptographic functions, arithmetic operations, and Bitcoin-related operations like timelocks.</p> </li> </ul>"},{"location":"documentation/simplicity-for-evm-developers/#how-does-simplicity-handle-inputs-and-external-data-like-signatures-or-transaction-details","title":"How does Simplicity handle inputs and external data, like signatures or transaction details?","text":"<p>Simplicity programs interact with data through explicit mechanisms:</p> <ul> <li> <p>Witness Combinators: The <code>witness</code> combinator returns a value provided at evaluation time, serving as inputs to Simplicity programs. These are analogous to Bitcoin Script's input stack in its <code>sigScript</code> or SegWit's witness. Type inference ensures witness data only contains nominally useful data and prevents padding with unused bits.</p> </li> <li> <p>Blockchain Primitives (Introspection): Simplicity includes primitive expressions that allow programs to read data from the transaction context where they are executed. This includes details about the transaction's inputs and outputs, locktime, and the commitment Merkle root of the program itself.  </p> </li> <li> <p>Assertions: The <code>assert</code> and <code>fail</code> expressions allow programs to halt execution if certain conditions are not met. This is similar to Bitcoin Script's <code>OP_VERIFY</code> or Ethereum's <code>STOP</code> opcode, validating checks like digital signature verification.</p> </li> </ul>"},{"location":"documentation/simplicity-for-evm-developers/#how-does-simplicitys-program-structure-differ-from-solidity-especially-regarding-privacy-and-efficiency","title":"How does Simplicity's program structure differ from Solidity, especially regarding privacy and efficiency?","text":"<p>Simplicity's structure is deeply rooted in functional programming and designed for efficiency and privacy:</p> <ul> <li> <p>Combinator-Based: Simplicity expressions are constructed from a small set of basic combinators (like <code>comp</code>, <code>pair</code>, <code>witness</code>, <code>iden</code>, <code>unit</code>, <code>injl</code>, <code>injr</code>, <code>take</code>, <code>drop</code>, <code>case</code>) which build up expressions from smaller ones.  </p> </li> <li> <p>Merkelized Abstract Syntax Trees (MASTs): Simplicity natively integrates MASTs. This means programs are arranged into trees, and only the portions necessary for redemption are revealed, pruning away unused parts. This increases privacy and decreases block space requirements.  </p> </li> <li> <p>Simplicity enables transparent sharing of identical subexpressions within a program. This allows complex logic, such as bounded loops, to be expressed more compactly. Even though shared subexpressions can make a program appear smaller than the work it performs, Simplicity\u2019s static analysis ensures that all programs have a known upper bound on resource usage, maintaining predictable and safe execution limits.</p> </li> </ul>"},{"location":"documentation/simplicity-for-evm-developers/#whats-the-type-system-like-in-simplicity-does-it-have-rich-data-structures","title":"What's the type system like in Simplicity? Does it have rich data structures?","text":"<p>Simplicity's type system is fundamental and rigorously defined:</p> <ul> <li> <p>Strictly Typed: Unlike Bitcoin\u2019s existing scripting language, Simplicity enforces strict typing rules, which helps eliminate certain classes of bugs and vulnerabilities.  </p> </li> <li> <p>Simple Type Forms: All types in Simplicity are combinations of just three basic forms:</p> </li> <li>Unit Type (1): Defines exactly one possible value, representing an \"empty output\"</li> <li>Product Type (A \u00d7 B): Composes a pair of types using an \"and\" operation, similar to tuples or records</li> <li>Sum Type (A + B): Combines two types in an \"or\" operation, similar to <code>Either</code> types in functional languages or tagged unions.</li> <li> <p>Finite Types: All types in Simplicity are finite. This means infinite or recursive types are not possible, ensuring termination and enabling rigorous analysis and verification.</p> </li> <li> <p>No Function Types or Named Variables: Simplicity has neither function types nor higher-order functions. It also has no named variables, relying on combinators to avoid binders and environments for bound variables.</p> </li> <li> <p>Type Inference: Simplicity uses first-order unification to perform type inference on Simplicity expressions, replacing any remaining type variables with the unit type. Because the types of pruned branches are discarded, the inferred types may end up smaller than in the originally committed program.</p> </li> </ul>"},{"location":"documentation/simplicity-for-evm-developers/#comparing-simplicity-and-solidity-scripts","title":"Comparing Simplicity and Solidity Scripts","text":"<p>Here's an example that shows the differences between both languages. An oracle signs a message with the current block height and the current price. The block height is compared with a minimum height to prevent the use of old data. The transaction is timelocked to the oracle height, which means that the transaction becomes valid after the oracle height.</p>"},{"location":"documentation/simplicity-for-evm-developers/#simplcity-example-source","title":"Simplcity Example (source)","text":"<pre><code>fn checksig(pk: Pubkey, sig: Signature) {\n    let msg: u256 = jet::sig_all_hash();\n    jet::bip_0340_verify((pk, msg), sig);\n}\n\nfn checksigfromstack(pk: Pubkey, bytes: [u32; 2], sig: Signature) {\n    let [word1, word2]: [u32; 2] = bytes;\n    let hasher: Ctx8 = jet::sha_256_ctx_8_init();\n    let hasher: Ctx8 = jet::sha_256_ctx_8_add_4(hasher, word1);\n    let hasher: Ctx8 = jet::sha_256_ctx_8_add_4(hasher, word2);\n    let msg: u256 = jet::sha_256_ctx_8_finalize(hasher);\n    jet::bip_0340_verify((pk, msg), sig);\n}\n\nfn main() {\n    let min_height: Height = 1000;\n    let oracle_height: Height = witness::ORACLE_HEIGHT;\n    assert!(jet::le_32(min_height, oracle_height));\n    jet::check_lock_height(oracle_height);\n\n    let target_price: u32 = 100000; // laser eyes until 100k\n    let oracle_price: u32 = witness::ORACLE_PRICE;\n    assert!(jet::le_32(target_price, oracle_price));\n\n    let oracle_pk: Pubkey = 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798; // 1 * G\n    let oracle_sig: Signature = witness::ORACLE_SIG;\n    checksigfromstack(oracle_pk, [oracle_height, oracle_price], oracle_sig);\n\n    let owner_pk: Pubkey = 0xc6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5; // 2 * G\n    let owner_sig: Signature = witness::OWNER_SIG;\n</code></pre>"},{"location":"documentation/simplicity-for-evm-developers/#solidity-example","title":"Solidity Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract HodlVault {\n    address public oracle;\n    address payable public recipient;\n    uint256 public priceThreshold; // e.g. $70,000 =&gt; 70000 * 1e8 if using 8 decimals\n    uint256 public minBlockHeight;\n    bool public claimed;\n\n    event Claimed(address recipient, uint256 price, uint256 blockHeight);\n\n    constructor(\n        address _oracle,\n        address payable _recipient,\n        uint256 _priceThreshold,\n        uint256 _minBlockHeight\n    ) payable {\n        oracle = _oracle;\n        recipient = _recipient;\n        priceThreshold = _priceThreshold;\n        minBlockHeight = _minBlockHeight;\n    }\n\n    // Oracle-signed message format:\n    // price: uint256 (e.g., 7000000000 for $70,000.0000)\n    // blockHeight: uint256\n    // v, r, s: ECDSA signature\n    function claim(uint256 price, uint256 blockHeight, uint8 v, bytes32 r, bytes32 s) external {\n        require(!claimed, \"Already claimed\");\n        require(price &gt;= priceThreshold, \"Price below threshold\");\n        require(blockHeight &gt;= minBlockHeight, \"Oracle block too old\");\n        require(block.number &gt;= blockHeight, \"Timelock: wait for oracle block\");\n\n        // Reconstruct the message the oracle signed\n        bytes32 message = keccak256(abi.encodePacked(price, blockHeight));\n        bytes32 ethSignedMessage = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", message));\n        address recovered = ecrecover(ethSignedMessage, v, r, s);\n        require(recovered == oracle, \"Invalid oracle signature\");\n\n        claimed = true;\n        recipient.transfer(address(this).balance);\n        emit Claimed(recipient, price, blockHeight);\n    }\n}\n</code></pre>"},{"location":"getting-started/","title":"Index","text":""},{"location":"getting-started/#quick-start-recommendations","title":"Quick Start Recommendations","text":"<p>For beginners and experimentation, we recommend starting with the WebIDE - it runs directly in your browser and requires no setup.</p> <p>For script development, start with SimplicityHL - the Rust-like high-level language that compiles down to core Simplicity.</p>"},{"location":"getting-started/#available-tools-implementations","title":"Available Tools &amp; Implementations","text":"Language/Tool Purpose Haskell Simplicity The reference implementation and also used to generate code for Rust and C implementations Coq/Rocq Simplicity Proofs The formal implementation C The consensus implementation Rust Simplicity The practical implementation in the form of a Rust library. SimplicityHL Rust-like high-level language that compiles down to Simplicity. Recommended starting point WebIDE A good way to test out Simplicity scripts directly in your browser. Command line tool Hal-Simplicity is a command line tool (written in Rust) based on <code>hal</code> by Stephen Roose VSCode Extension Provides syntax highlighting for the SimplicityHL programming language. ZKP A zero knowledge prover written in SimplicityHL <p>Next Steps: Try out the WebIDE to get a feel for Simplicity, then dive into SimplicityHL for your first real projects.</p>"},{"location":"getting-started/simplicityhl/","title":"SimplicityHL","text":"<p>A basic pay-to-pubkey SimplicityHL program looks like this:</p> <pre><code>fn main(pubkey: Pubkey, funds: Funds) -&gt; Funds {\n    let (witness = _, funds) = commit(\n        Witness = ValidSignature(pubkey, funds),\n        funds,\n    );\n    funds\n}\n</code></pre> <p>A person sending money with this contract supplies the receiver's pubkey (<code>pubkey</code>) and the funds that they're sending (<code>funds</code>). The first thing that <code>main</code> does is call the built-in <code>commit</code> function. This marks the point where the actual on-chain code begins. Until control flow reaches <code>commit</code>, code is merely executing in the sender's wallet. eg. if <code>main</code> had instead returned <code>funds</code> directly without calling <code>commit</code> then the wallet would simply hand the user's money straight back to them without creating a transaction.</p> <p>The signature of <code>commit</code> is:</p> <pre><code>fn commit(Witness: Type, funds: Funds) -&gt; struct { witness: Witness, funds: Funds }\n</code></pre> <p><code>Witness</code> is the type that needs to be satisfied in order to unlock the funds and continue program execution. In this case Witness is <code>ValidSignature(pubkey, funds)</code> - ie. a signature (by the owner of <code>pubkey</code>) signing the funds (ie. the transaction spending the utxo). Actual validation of the signature happens inside the <code>ValidSignature</code> type which would be defined something like this:</p> <pre><code>fn ValidSignature(pubkey: Pubkey, funds: Funds) -&gt; Type {\n    struct {\n        signature: Signature,\n        is_valid: true == jet::bip_0340_check(pubkey, jet::sig_all_hash(funds), signature),\n    }\n}\n</code></pre> <p>(Note that functions under the BC monad (in this case <code>jet::sig_all_hash</code> can be modelled as pure functions which take a <code>Funds</code> argument.)</p> <p>The compiled Simplicity code starts at the point where <code>commit</code> returns and immediately verifies that the witness data is a valid value of the SimplicityHL type (which may have less valid values than the low-level Simplicity type used to represent it). In this case, the Simplicity type (sans optimizations) would be <code>2^512 * 1</code> since its a struct containing a <code>Signature</code> (represented as <code>2^512</code>) and an equality (represented as <code>1</code>). The only value of an equality is <code>refl(x)</code> of type <code>x == x</code> represented as the unit value. When <code>x</code> and <code>y</code> are not equal the type <code>x == y</code> is uninhabited and the unit value is not a valid representation of the type. ie. the witness validation code for this program simply calls <code>bip_0340_check</code> and asserts that it returns <code>true</code>.</p> <p><code>commit</code> returns both the provided witness data and a new value of type <code>Funds</code>. The final thing this program does is to release control of the funds by returning it.</p>"},{"location":"resources/contribute/","title":"Contribute","text":"<p>instructions on how to help the project</p>"},{"location":"resources/faq/","title":"Simplicity FAQ","text":""},{"location":"resources/faq/#simplicity-is-so-simple-it-fits-on-a-t-shirt-does-that-mean-its-as-limited-as-bitcoin-script","title":"Simplicity is so simple it fits on a T-shirt. Does that mean it's as limited as Bitcoin Script?","text":"<p>No, the \"simplicity\" refers to its foundational design and formal semantics, not its expressiveness.</p> <ul> <li> <p>Bitcoin Script is deliberately limited; Simplicity is finitarily complete \u2192 it can program any finite computation.</p> </li> <li> <p>Complex off-chain (even Turing-complete) computations can be verified on-chain with Simplicity.</p> </li> </ul>"},{"location":"resources/faq/#is-simplicity-turing-complete-like-evm","title":"Is Simplicity Turing-complete like EVM?","text":"<p>No, and that\u2019s a feature!</p> <ul> <li> <p>Predictable Resource Costs: No \u201cout of gas\u201d issues; costs are known at compile-time.</p> </li> <li> <p>Guaranteed Termination: No unbounded loops/recursion \u2192 all programs halt.</p> </li> <li> <p>Enhanced Verifiability: Programs are analyzable, enabling formal reasoning.</p> </li> </ul>"},{"location":"resources/faq/#how-does-simplicity-handle-state-does-it-have-global-state-like-ethereum","title":"How does Simplicity handle state? Does it have global state like Ethereum?","text":"<p>Simplicity has no global state. It is a purely functional language: each program is just a function mapping inputs \u2192 outputs.</p> <p>Contracts run within the Bitcoin UTXO model:</p> <ol> <li> <p>Contracts are small programs attached to UTXOs that guard the associated coins.</p> </li> <li> <p>Spending a UTXO means providing witness data so the contract evaluates to true.</p> </li> <li> <p>State is carried forward explicitly by committing data into the next UTXO.</p> </li> </ol> <p>This design avoids shared mutable state (as in Ethereum). Instead, every transition is localized: a UTXO is consumed, and the updated state is re-committed into the new UTXO.</p>"},{"location":"resources/faq/#how-do-i-prove-my-simplicity-contract-is-correct","title":"How do I prove my Simplicity contract is correct?","text":"<p>Formal verification happens in Coq/Rocq, not directly in Simplicity.</p> <p>Process:</p> <ol> <li> <p>Simplicity semantics are modeled in Coq.</p> </li> <li> <p>You prove correctness properties (safety, termination, resource use).</p> </li> <li> <p>Proofs give guarantees before deployment.</p> </li> </ol>"},{"location":"resources/faq/#simplicity-is-low-level-do-i-write-contracts-directly-in-it","title":"Simplicity is low-level. Do I write contracts directly in it?","text":"<p>Not usually. There are higher-level options:</p> Tool Description SimplicityHL Rust-like syntax compiling to Simplicity Web IDE Try Simfony examples in the browser Haskell Implementation Build Simplicity expressions in a tagless-final style <p>The future vision is that there are multiple high-level languages which all compile down to Simplicity + proofs.</p>"},{"location":"resources/faq/#what-are-jets-and-how-do-they-make-programs-efficient","title":"What are Jets, and how do they make programs efficient?","text":"<p>A Simplicity jet is a pre-defined, optimized function that replaces an equivalent Simplicity expression to speed up execution without changing its meaning.</p> <p>Benefits:</p> <ul> <li> <p>Programs remain formally verifiable.</p> </li> <li> <p>Heavy operations run in optimized C instead of interpreted combinators.</p> </li> <li> <p>Keeps execution fast, compact, and analyzable.</p> </li> </ul>"},{"location":"resources/faq/#how-does-simplicity-exist-alongside-bitcoin-script","title":"How does Simplicity exist alongside Bitcoin script?","text":"<p>With Taproot\u2019s versioned leaves, a single Taproot output can include both standard Script/Miniscript leaves and a Simplicity leaf. This allows mixing policies: simple paths can remain in Script while advanced paths use Simplicity, preserving flexibility and privacy under one Taptree.</p>"},{"location":"resources/faq/#how-do-i-track-the-value-of-a-simplicity-contract-with-partial-payouts-when-different-strike-prices-are-being-matched","title":"How do I track the value of a Simplicity contract with partial payouts when different strike prices are being matched?","text":"<p>Simplicity contracts operate on UTXO-committed state. Each contract output carries forward a table of strikes together with their remaining notionals.</p> <p>At every settlement event, the contract:</p> <ol> <li> <p>Reads the current reference price.</p> </li> <li> <p>Applies partial payouts to any strikes that are matched.</p> </li> <li> <p>Updates the strike table by reducing the notional amounts that have been settled.</p> </li> </ol> <p>The value of the contract at any point is given by the piecewise payoff function, evaluated against the latest UTXO state. By inspecting the most recent UTXO, participants can determine both their current position and their outstanding exposure. (see also: Bitcoin Optech comment from AJ Towns on flexible coin earmarks)</p>"},{"location":"resources/roadmap/","title":"Simplicity Roadmap","text":"<p>The primary objective for the current development cycle is to prepare Simplicity for execution on a Bitcoin test network. Achieving this objective requires finalising the set of jets, establishing a complete cost model, and implementing state storage for advanced contract functionality.</p>"},{"location":"resources/roadmap/#bitcoin-testnet-integration","title":"Bitcoin Testnet Integration","text":"<p>Work will continue towards producing a signet-mergeable integration branch of bitcoin-core containing Simplicity. Key tasks include:</p> <ul> <li>Porting <code>libsimplicity</code> into the integration branch.</li> <li>Ensuring all jets are fully implemented and functioning.</li> <li>Assigning execution costs to each jet.</li> </ul>"},{"location":"resources/roadmap/#state-storage-in-simplicity","title":"State Storage in Simplicity","text":"<p>Implementation of UTXO-committed state storage is planned to support advanced contract use cases, including covenants and vaults. This requires:</p> <ul> <li>Defining the state storage API and on-chain commitment structure.</li> <li>Producing reference examples demonstrating stateful contracts.</li> <li>Documenting usage patterns for developers.</li> <li>Implementation in SimplicityHL</li> </ul>"},{"location":"resources/roadmap/#path-to-testnet-deployment","title":"Path to Testnet Deployment","text":"<p>The following sequence outlines the progression towards a Bitcoin testnet release:</p> <ol> <li>Completion of jet implementation and cost assignments.</li> <li>Availability of the signet-mergeable integration branch.</li> <li>Implementation of state storage, enabling contracts such as covenants and vaults.</li> <li>Deployment of Simplicity on Bitcoin testnet.</li> </ol>"},{"location":"simplicityhl-reference/","title":"Introduction","text":"<p>SimplicityHL is a high-level language for writing Bitcoin smart contracts. In other words, SimplicityHL is a language for expressing spending conditions of UTXOs on the Bitcoin blockchain.</p> <p>SimplicityHL looks and feels like Rust. Developers write SimplicityHL, Bitcoin full nodes run Simplicity.</p>"},{"location":"simplicityhl-reference/#types-and-values","title":"Types and Values","text":"<ul> <li>Types and Values</li> <li>Type Aliases</li> <li>Type Casting</li> </ul>"},{"location":"simplicityhl-reference/#writing-a-program","title":"Writing a Program","text":"<ul> <li>Let Statements</li> <li>Match Expression</li> <li>Functions</li> <li>Programs</li> </ul>"},{"location":"simplicityhl-reference/context/","title":"Context","text":"<p>A context \u0393 maps variable names to Simplicity types:</p> <p>\u0393 = [ <code>foo</code> \u21a6 \ud835\udfd9, <code>bar</code> \u21a6 \ud835\udfda^32?, <code>baz</code> \u21a6 \ud835\udfda^32 \u00d7 \ud835\udfd9 ]</p> <p>We write \u0393(<code>v</code>) = A to denote that variable <code>v</code> has type A in context \u0393.</p> <p>We handle free variables inside SimplicityHL expressions via contexts.</p> <p>If all free variables are defined in a context, then the context assigns a type to the expression.</p> <p>We write \u0393 \u22a9 <code>a</code>: A to denote that expression <code>a</code> has type A in context \u0393.</p> <p>Note that contexts handle only the target type of an expression!</p> <p>Source types are handled by environments and the translation of SimplicityHL to Simplicity.</p> <p>We write \u0393 \u228e \u0394 to denote the disjoint union of \u0393 and \u0394.</p> <p>We write \u0393 // \u0394 to denote the update of \u0393 with \u0394. The update contains mappings from both contexts. If a variable is present in both, then the mapping from \u0394 is taken.</p>"},{"location":"simplicityhl-reference/context/#unit-literal","title":"Unit literal","text":"<p>\u0393 \u22a9 <code>()</code>: \ud835\udfd9</p>"},{"location":"simplicityhl-reference/context/#product-constructor","title":"Product constructor","text":"<p>If \u0393 \u22a9 <code>b</code>: B</p> <p>If \u0393 \u22a9 <code>c</code>: C</p> <p>Then \u0393 \u22a9 <code>(b, c)</code>: B \u00d7 C</p>"},{"location":"simplicityhl-reference/context/#left-constructor","title":"Left constructor","text":"<p>If \u0393 \u22a9 <code>b</code>: B</p> <p>Then \u0393 \u22a9 <code>Left(b)</code>: B + C</p> <p>For any C</p>"},{"location":"simplicityhl-reference/context/#right-constructor","title":"Right constructor","text":"<p>If \u0393 \u22a9 <code>c</code>: c</p> <p>Then \u0393 \u22a9 <code>Right(c)</code>: B + C</p> <p>For any B</p>"},{"location":"simplicityhl-reference/context/#bit-string-literal","title":"Bit string literal","text":"<p>If <code>s</code> is a bit string of 2^n bits</p> <p>Then \u0393 \u22a9 <code>0bs</code>: \ud835\udfda^(2^n)</p>"},{"location":"simplicityhl-reference/context/#byte-string-literal","title":"Byte string literal","text":"<p>If <code>s</code> is a hex string of 2^n digits</p> <p>Then \u0393 \u22a9 <code>0xs</code>: \ud835\udfda^(4 * 2^n)</p>"},{"location":"simplicityhl-reference/context/#variable","title":"Variable","text":"<p>If \u0393(<code>v</code>) = B</p> <p>Then \u0393 \u22a9 <code>v</code>: B</p>"},{"location":"simplicityhl-reference/context/#witness-value","title":"Witness value","text":"<p>\u0393 \u22a9 <code>witness(name)</code>: B</p> <p>For any B</p>"},{"location":"simplicityhl-reference/context/#jet","title":"Jet","text":"<p>If <code>j</code> is the name of a jet of type B \u2192 C</p> <p>If \u0393 \u22a9 <code>b</code>: B</p> <p>Then \u0393 \u22a9 <code>jet::j b</code>: C</p>"},{"location":"simplicityhl-reference/context/#chaining","title":"Chaining","text":"<p>If \u0393 \u22a9 <code>b</code>: \ud835\udfd9</p> <p>If \u0393 \u22a9 <code>c</code>: C</p> <p>Then \u0393 \u22a9 <code>b; c</code>: C</p>"},{"location":"simplicityhl-reference/context/#patterns","title":"Patterns","text":"<p>Type A and pattern <code>p</code> create a context denoted by PCtx(A, <code>p</code>)</p> <p>PCtx(A, <code>v</code>) := [<code>v</code> \u21a6 A]</p> <p>PCtx(A, <code>_</code>) := []</p> <p>If <code>p1</code> and <code>p2</code> map disjoint sets of variables</p> <p>Then PCtx(A \u00d7 B, <code>(p1, p2)</code>) := PCtx(A, <code>p1</code>) \u228e PCtx(B, <code>p2</code>)</p>"},{"location":"simplicityhl-reference/context/#let-statement","title":"Let statement","text":"<p>If \u0393 \u22a9 <code>b</code>: B</p> <p>If \u0393 // PCtx(B, <code>p</code>) \u22a9 <code>c</code>: C</p> <p>Then \u0393 \u22a9 <code>let p: B = b; c</code>: C</p> <p>With alternative syntax</p> <p>Then \u0393 \u22a9 <code>let p = b; c</code>: C</p>"},{"location":"simplicityhl-reference/context/#match-statement","title":"Match statement","text":"<p>If \u0393 \u22a9 <code>a</code>: B + C</p> <p>If \u0393 // [<code>x</code> \u21a6 B] \u22a9 <code>b</code>: D</p> <p>If \u0393 // [<code>y</code> \u21a6 C] \u22a9 <code>c</code>: D</p> <p>Then \u0393 \u22a9 <code>match a { Left(x) =&gt; b, Right(y) =&gt; c, }</code>: D</p> <p>(We do not enforce that <code>x</code> is used inside <code>b</code> or <code>y</code> inside <code>c</code>. Writing stupid programs is allowed, although there will be a compiler warning at some point.)</p>"},{"location":"simplicityhl-reference/context/#left-unwrap","title":"Left unwrap","text":"<p>If \u0393 \u22a9 <code>b</code>: B + C</p> <p>Then \u0393 \u22a9 <code>b.unwrap_left()</code>: B</p>"},{"location":"simplicityhl-reference/context/#right-unwrap","title":"Right unwrap","text":"<p>If \u0393 \u22a9 <code>c</code>: B + C</p> <p>Then \u0393 \u22a9 <code>c.unwrap_right()</code>: C</p>"},{"location":"simplicityhl-reference/environment/","title":"Environment","text":"<p>An environment \u039e maps variable names to Simplicity expressions.</p> <p>All expressions inside an environment share the same source type A. We say the environment is \"from type A\".</p> <pre><code>\u039e =\n[ foo \u21a6 unit:      (\ud835\udfda^32? \u00d7 2^32) \u2192 \ud835\udfd9\n, bar \u21a6 take iden: (\ud835\udfda^32? \u00d7 \ud835\udfda^32) \u2192 \ud835\udfda^32?\n, baz \u21a6 drop iden: (\ud835\udfda^32? \u00d7 \ud835\udfda^32) \u2192 \ud835\udfda^32\n]\n</code></pre> <p>We use environments to translate variables inside SimplicityHL expressions to Simplicity.</p> <p>The environment tells us the Simplicity expression that returns the value of each variable.</p> <p>We translate a SimplicityHL program \"top to bottom\". Each time a variable is defined, we update the environment to reflect this change.</p> <p>During the translation, we can ignore the source type of Simplicity expressions (translated SimplicityHL expressions) entirely. We can focus on producing a Simplicity value of the expected target type. Environments ensure that we get input values for each variable that is in scope.</p> <p>Target types are handled by contexts.</p> <p>We obtain context Ctx(\u039e) from environment \u039e by mapping each variable <code>x</code> from \u039e to the target type of \u039e(<code>x</code>):</p> <p>Ctx(\u039e)(<code>x</code>) = B if \u039e(<code>x</code>) = a: A \u2192 B</p>"},{"location":"simplicityhl-reference/environment/#patterns","title":"Patterns","text":"<p>Patterns occur in let statements <code>let p := s</code>.</p> <p>Pattern <code>p</code> binds the output of SimplicityHL expression <code>s</code> to variables.</p> <p>As we translate <code>s</code> to Simplicity, we need an environment that maps the variables from <code>p</code> to Simplicity expressions.</p> <p>If <code>p</code> is just a variable <code>p = a</code>, then the environment is simply [<code>a</code> \u21a6 iden: A \u2192 A].</p> <p>If <code>p</code> is a product of two variables <code>p = (a, b)</code>, then the environment is [<code>a</code> \u21a6 take iden: A \u00d7 B \u2192 A, <code>b</code> \u21a6 drop iden: A \u00d7 B \u2192 B].</p> <p>\"take\" and \"drop\" are added as we go deeper in the product hierarchy. The pattern <code>_</code> is ignored.</p> <p>PEnv'(t: A \u2192 B, <code>v</code>) := [<code>v</code> \u21a6 t]</p> <p>PEnv'(t: A \u2192 B, <code>_</code>) := []</p> <p>If <code>p1</code> and <code>p2</code> contain disjoint sets of variables</p> <p>Then PEnv'(t: A \u2192 B \u00d7 C, <code>(p1, p2)</code>) := PEnv'(take t: A \u2192 B, p1) \u228e PEnv'(drop t: A \u2192 C, p2)</p> <p>PEnv(A, <code>p</code>) := PEnv'(iden: A \u2192 A, <code>p</code>)</p> <p>Pattern environments are compatible with pattern contexts:</p> <p>Ctx(PEnv(A, <code>p</code>)) = PCtx(A, <code>p</code>)</p>"},{"location":"simplicityhl-reference/environment/#product","title":"Product","text":"<p>We write Product(\u039eA, \u039eB) to denote the product of environment \u039eA from A and environment \u039eB from B.</p> <p>The product is an environment from type A \u00d7 B.</p> <p>When two Simplicity expressions with environments are joined using the \"pair\" combinator, then the product of both environments gives us updated bindings for all variables.</p> <p>If the same variable is bound in both environments, then the binding from the first environment is taken.</p> <p>If \u039eA maps <code>v</code> to Simplicity expression a: A \u2192 C</p> <p>Then Product(\u039eA, \u039eB) maps <code>v</code> to take a: A \u00d7 B \u2192 C</p> <p>If \u039eB maps <code>v</code> to Simplicity expression b: B \u2192 C</p> <p>If \u039eA doesn't map <code>v</code></p> <p>Then Product(\u039eA, \u039eB) maps <code>v</code> to drop b: A \u00d7 B \u2192 C</p> <p>Environment products are compatible with context updates:</p> <p>Ctx(Product(\u039eA, \u039eB)) = Ctx(\u039eB) // Ctx(\u039eA)</p> <p>The order of B and A is reversed: The context of \u039eB is updated with the dominant context of \u039eA.</p>"},{"location":"simplicityhl-reference/function/","title":"Functions","text":"<p>Functions are defined and called just like in Rust.</p> <pre><code>fn add(x: u32, y: u32) -&gt; u32 {\n    let (carry, sum): (bool, u32) = jet::add_32(x, y);\n    match carry {\n        true =&gt; panic!(), // overflow\n        false =&gt; {}, // ok\n    };\n    sum\n}\n</code></pre> <p>The above example defines a function called <code>add</code> that takes two parameters: variable <code>x</code> of type <code>u32</code> and variable <code>y</code> of type <code>u32</code>. The function returns a value of type <code>u32</code>.</p> <p>The body of the function is a block expression <code>{ ... }</code> that is executed from top to bottom. The function returns on the final line (note the missing semicolon <code>;</code>). In the above example, <code>x</code> and <code>y</code> are added via the <code>add_32</code> jet. The function then checks if the carry is true, signaling an overflow, in which case it panics. On the last line, the value of <code>sum</code> is returned.</p> <p>The above function is called by writing its name <code>add</code> followed by a list of arguments <code>(40, 2)</code>. Each parameter needs an argument, so the list of arguments is as long as the list of parameters. Here, <code>x</code> is assigned the value <code>40</code> and <code>y</code> is assigned the value <code>2</code>.</p> <pre><code>let z: u32 = add(40, 2);\n</code></pre>"},{"location":"simplicityhl-reference/function/#no-early-returns","title":"No early returns","text":"<p>SimplicityHL has no support for an early return via a \"return\" keyword. The only branching that is available is via match expressions.</p>"},{"location":"simplicityhl-reference/function/#no-recursion","title":"No recursion","text":"<p>SimplicityHL has no support for recursive function calls. A function can be called inside a function body if it has been defined before. This means that a function cannot call itself. Loops, where <code>f</code> calls <code>g</code> and <code>g</code> calls <code>f</code>, are also impossible.</p> <p>What is possible are stratified function definitions, where level-0 functions depend on nothing, level-1 functions depend on level-0 functions, and so on.</p> <pre><code>fn level_0() -&gt; u32 {\n    0\n}\n\nfn level_1() -&gt; u32 {\n    let (_, next) = jet::increment_32(level_0());\n    next\n}\n\nfn level_2() -&gt; u32 {\n    let (_, next) = jet::increment_32(level_1());\n    next\n}\n</code></pre>"},{"location":"simplicityhl-reference/function/#order-matters","title":"Order matters","text":"<p>If function <code>g</code> calls function <code>f</code>, then <code>f</code> must be defined before <code>g</code>.</p> <pre><code>fn f() -&gt; u32 {\n    42\n}\n\nfn g() -&gt; u32 {\n    f()\n}\n</code></pre>"},{"location":"simplicityhl-reference/function/#main-function","title":"Main function","text":"<p>The <code>main</code> function is the entry point of each SimplicityHL program. Running a program means running its <code>main</code> function. Other functions are called from the <code>main</code> function.</p> <pre><code>fn main() {\n    // ...\n}\n</code></pre> <p>The <code>main</code> function is a reserved name and must exist in every program. SimplicityHL programs are always \"binaries\". There is no support for \"libraries\".</p>"},{"location":"simplicityhl-reference/function/#jets","title":"Jets","text":"<p>Jets are predefined and optimized functions for common use cases.</p> <pre><code>jet::add_32(40, 2)\n</code></pre> <p>Jets live inside the namespace <code>jet</code>, which is why they are prefixed with <code>jet::</code>. They can be called without defining them manually.</p> <p>It is usually more efficient to call a jet than to manually compute a value.</p> <p>The jet documentation lists each jet and explains what it does.</p>"},{"location":"simplicityhl-reference/let_statement/","title":"Let Statement","text":"<p>Variables are defined in let statements, just like in Rust.</p> <pre><code>let x: u32 = 1;\n</code></pre> <p>The above let statement defines a variable called <code>x</code>. The variable is of type <code>u32</code> and it is assigned the value <code>1</code>.</p> <pre><code>let x: u32 = f(1337);\n</code></pre> <p>Variables can be assigned to the output value of any expression, such as function calls.</p>"},{"location":"simplicityhl-reference/let_statement/#explicit-typing","title":"Explicit typing","text":"<p>In SimplicityHL, the type of a defined variable always has to be written. This is different from Rust, which has better type inference.</p>"},{"location":"simplicityhl-reference/let_statement/#immutability","title":"Immutability","text":"<p>SimplicityHL variables are always immutable. There are no mutable variables.</p>"},{"location":"simplicityhl-reference/let_statement/#redefinition-and-scoping","title":"Redefinition and scoping","text":"<p>The same variable can be defined twice in the same scope. The later definition overrides the earlier definition.</p> <pre><code>let x: u32 = 1;\nlet x: u32 = 2;\nassert!(jet::eq_32(x, 2)); // x == 2\n</code></pre> <p>Normal scoping rules apply: Variables from outer scopes are available inside inner scopes. A variable defined in an inner scope shadows a variable of the same name from an outer scope.</p> <pre><code>let x: u32 = 1;\nlet y: u32 = 2;\nlet z: u32 = {\n    let x: u32 = 3;\n    assert!(jet::eq_32(y, 2)); // y == 2\n    x\n};\nassert!(jet::eq_32(z, 3)); // z == 3\n</code></pre>"},{"location":"simplicityhl-reference/let_statement/#pattern-matching","title":"Pattern matching","text":"<p>There is limited pattern matching support inside let statements.</p> <pre><code>let (x, y, _): (u8, u16, u32) = (1, 2, 3);\nlet [x, _, z]: [u32; 3] = [1, 2, 3];\n</code></pre> <p>In the first line, the tuple <code>(1, 2, 3)</code> is deconstructed into the values <code>1</code>, <code>2</code> and <code>3</code>. These values are assigned to the variable names <code>x</code>, <code>y</code> and <code>_</code>. The variable name <code>_</code> is a special name that ignores its value. In the end, two variables are created: <code>x: u32 = 1</code> and <code>y: u16 = 2</code>.</p> <p>Similarly, arrays can be deconstructed element by element and assigned to a variable each.</p>"},{"location":"simplicityhl-reference/match_expression/","title":"Match Expression","text":"<p>A match expression conditionally executes code branches. Which branch is executed depends on the input to the match expression.</p> <pre><code>let result: u32 = match f(42) {\n    Left(x: u32) =&gt; x,\n    Right(x: u16) =&gt; jet::left_pad_low_16_32(x),\n};\n</code></pre> <p>In the above example, the output of the function call <code>f(42)</code> is matched. <code>f</code> returns an output of type <code>Either&lt;u32, u16&gt;</code>. If <code>f(42)</code> returns a value that matches the pattern <code>Left(x: u32)</code>, then the first match arm is executed. This arm simply returns the value <code>x</code>. Alternatively, if <code>f(42)</code> returns a value that matches the pattern <code>Right(x: u16)</code>, then the second match arm is executed. This arm extends the 16-bit number <code>x</code> to a 32-bit number by padding its left with zeroes. Because of type constraints, the output of <code>f</code> must match one of these two patterns. The whole match expression returns a value of type <code>u32</code>, from one of the two arms.</p>"},{"location":"simplicityhl-reference/match_expression/#explicit-typing","title":"Explicit typing","text":"<p>In SimplicityHL, the type of variables inside match arms must always be written. This is different from Rust, which has better type inference.</p>"},{"location":"simplicityhl-reference/match_expression/#pattern-matching","title":"Pattern matching","text":"<p>There is limited support for pattern matching inside match expressions.</p> <p>Boolean values can be matched. The Boolean match expression is the replacement for an \"if-then-else\" in SimplicityHL.</p> <pre><code>let bit_flip: bool = match false {\n    false =&gt; true,\n    true =&gt; false,\n};\n</code></pre> <p>Optional values can be matched. The <code>Some</code> arm introduces a variable which must be explicitly typed.</p> <pre><code>let unwrap_or_default: u32 = match Some(42) {\n    None =&gt; 0,\n    Some(x: u32) =&gt; x,\n};\n</code></pre> <p>Finally, <code>Either</code> values can be matched. Again, variables that are introduced in match arms must be explicitly typed.</p> <pre><code>let map_either: u32 = match Left(1337) {\n    Left(x: u32) =&gt; f(x),\n    Right(y: u32) =&gt; f(y),\n};\n</code></pre> <p>Match expressions don't support further pattern matching, in contrast to Rust.</p> <pre><code>let unwrap_or_default: u32 = match Some((4, 2)) {\n    None =&gt; 0,\n    // this doesn't compile\n    Some((y, z): (u16, u16)) =&gt; &lt;(u16, u16)&gt;::into((y, z)),\n};\n</code></pre> <p>However, the match arm can contain code that performs the deconstruction. For example, the tuple <code>x</code> of type <code>(u16, u16)</code> can be deconstructed into two integers <code>y</code> and <code>z</code> of type <code>u16</code>.</p> <pre><code>let unwrap_or_default: u32 = match Some((4, 2)) {\n    None =&gt; 0,\n    Some(x: (u16, u16)) =&gt; {\n        let (y, z): (u16, u16) = x;\n        &lt;(u16, u16)&gt;::into((y, z))\n    }\n};\n</code></pre> <p>The match arm can also contain match expressions for further deconstruction. For example, the sum value <code>x</code> of type <code>Either&lt;u32, u32&gt;</code> can be matched as either <code>Left(y: u32)</code> or <code>Right(z: u32)</code>.</p> <pre><code>let unwrap_or_default: u32 = match Some(Left(42)) {\n    None =&gt; 0,\n    Some(x: Either&lt;u32, u32&gt;) =&gt; match x {\n        Left(y: u32) =&gt; y,\n        Right(z: u32) =&gt; z,\n    },\n};\n</code></pre>"},{"location":"simplicityhl-reference/program/","title":"Programs","text":"<p>A SimplicityHL program consists of a <code>main</code> function.</p> <p>A program may also have type aliases or custom function definitions. The <code>main</code> function comes last in the program, because everything it calls must be defined before it.</p> <pre><code>type Furlong = u32;\ntype Mile = u32;\n\nfn to_miles(distance: Either&lt;Furlong, Mile&gt;) -&gt; Mile {\n    match distance {\n        Left(furlongs: Furlong) =&gt; jet::divide_32(furlongs, 8),\n        Right(miles: Mile) =&gt; miles,\n    }\n}\n\nfn main() {\n    let eight_furlongs: Either&lt;Furlong, Mile&gt; = Left(8);\n    let one_mile: Either&lt;Furlong, Mile&gt; = Right(1);\n    assert!(jet::eq_32(1, to_miles(eight_furlongs)));\n    assert!(jet::eq_32(1, to_miles(one_mile)));\n}\n</code></pre>"},{"location":"simplicityhl-reference/translation/","title":"Translation","text":"<p>We write \u27e6<code>e</code>\u27e7\u039e to denote the translation of SimplicityHL expression <code>e</code> using environment \u039e from A.</p> <p>The translation produces a Simplicity expression with source type A.</p> <p>The target type depends on the SimplicityHL expression <code>e</code>.</p>"},{"location":"simplicityhl-reference/translation/#unit-literal","title":"Unit literal","text":"<p>\u27e6<code>()</code>\u27e7\u039e = unit: A \u2192 \ud835\udfd9</p>"},{"location":"simplicityhl-reference/translation/#product-constructor","title":"Product constructor","text":"<p>If Ctx(\u039e) \u22a9 <code>b</code>: B</p> <p>If Ctx(\u039e) \u22a9 <code>c</code>: C</p> <p>Then \u27e6<code>(b, c)</code>\u27e7\u039e = pair \u27e6<code>b</code>\u27e7\u039e \u27e6<code>c</code>\u27e7\u039e: A \u2192 B \u00d7 C</p>"},{"location":"simplicityhl-reference/translation/#left-constructor","title":"Left constructor","text":"<p>If Ctx(\u039e) \u22a9 <code>b</code>: B</p> <p>Then \u27e6<code>Left(b)</code>\u27e7\u039e = injl \u27e6<code>b</code>\u27e7\u039e: A \u2192 B + C</p> <p>For any C</p>"},{"location":"simplicityhl-reference/translation/#right-constructor","title":"Right constructor","text":"<p>If Ctx(\u039e) \u22a9 <code>c</code>: C</p> <p>Then \u27e6<code>Right(c)</code>\u27e7\u039e = injr \u27e6<code>c</code>\u27e7\u039e: A \u2192 B + C</p> <p>For any B</p>"},{"location":"simplicityhl-reference/translation/#bit-string-literal","title":"Bit string literal","text":"<p>If <code>s</code> is a bit string of 2^n bits</p> <p>Then \u27e6<code>0bs</code>\u27e7\u039e = comp unit const 0bs: A \u2192 \ud835\udfda^(2^n)</p>"},{"location":"simplicityhl-reference/translation/#byte-string-literal","title":"Byte string literal","text":"<p>If <code>s</code> is a hex string of 2^n digits</p> <p>Then \u27e6<code>0xs</code>\u27e7\u039e = comp unit const 0xs: A \u2192 \ud835\udfda^(4 * 2^n)</p>"},{"location":"simplicityhl-reference/translation/#variable","title":"Variable","text":"<p>If Ctx(\u039e)(<code>v</code>) = B</p> <p>Then \u27e6<code>v</code>\u27e7\u039e = \u039e(<code>v</code>): A \u2192 B</p>"},{"location":"simplicityhl-reference/translation/#witness-value","title":"Witness value","text":"<p>Ctx(\u039e) \u22a9 <code>witness(name)</code>: B</p> <p>Then \u27e6<code>witness(name)</code>\u27e7\u039e = witness: A \u2192 B</p>"},{"location":"simplicityhl-reference/translation/#jet","title":"Jet","text":"<p>If <code>j</code> is the name of a jet of type B \u2192 C</p> <p>If Ctx(\u039e) \u22a9 <code>b</code>: B</p> <p>Then \u27e6<code>jet::j b</code>\u27e7\u039e = comp \u27e6<code>b</code>\u27e7\u039e j: A \u2192 C</p>"},{"location":"simplicityhl-reference/translation/#chaining","title":"Chaining","text":"<p>If Ctx(\u039e) \u22a9 <code>b</code>: \ud835\udfd9</p> <p>If Ctx(\u039e) \u22a9 <code>c</code>: C</p> <p>Then \u27e6<code>b; c</code>\u27e7\u039e = comp (pair \u27e6<code>b</code>\u27e7\u039e \u27e6<code>c</code>\u27e7\u039e) (drop iden): A \u2192 C</p>"},{"location":"simplicityhl-reference/translation/#let-statement","title":"Let statement","text":"<p>If Ctx(\u039e) \u22a9 <code>b</code>: B</p> <p>If Product(PEnv(B, <code>p</code>), \u039e) \u22a9 <code>c</code>: C</p> <p>Then \u27e6<code>let p: B = b; c</code>\u27e7\u039e = comp (pair \u27e6<code>b</code>\u27e7\u039e iden) \u27e6<code>c</code>\u27e7Product(PEnv(B, <code>p</code>), \u039e): A \u2192 C</p>"},{"location":"simplicityhl-reference/translation/#match-statement","title":"Match statement","text":"<p>If Ctx(\u039e) \u22a9 <code>a</code>: B + C</p> <p>If Product(PEnv(B, <code>x</code>), \u039e) \u22a9 <code>b</code>: D</p> <p>If Product(PEnv(C, <code>y</code>), \u039e) \u22a9 <code>c</code>: D</p> <p>Then \u27e6<code>match a { Left(x) =&gt; b, Right(y) =&gt; c, }</code>\u27e7\u039e = comp (pair \u27e6<code>a</code>\u27e7\u039e iden) (case \u27e6<code>b</code>\u27e7Product(PEnv(B, <code>x</code>), \u039e) \u27e6<code>c</code>\u27e7Product(PEnv(C, <code>y</code>), \u039e)): A \u2192 D</p>"},{"location":"simplicityhl-reference/translation/#left-unwrap","title":"Left unwrap","text":"<p>If Ctx(\u039e) \u22a9 <code>b</code>: B + C</p> <p>Then \u27e6<code>b.unwrap_left()</code>\u27e7\u039e = comp (pair \u27e6<code>b</code>\u27e7\u039e unit) (assertl iden #{fail 0}): A \u2192 B</p>"},{"location":"simplicityhl-reference/translation/#right-unwrap","title":"Right unwrap","text":"<p>If Ctx(\u039e) \u22a9 <code>c</code>: B + C</p> <p>Then \u27e6<code>c.unwrap_right()</code>\u27e7\u039e = comp (pair \u27e6<code>c</code>\u27e7\u039e unit) (assertr #{fail 0} iden): A \u2192 C</p>"},{"location":"simplicityhl-reference/type/","title":"Types and Values","text":"<p>SimplicityHL mostly uses a subset of Rust's types. It extends Rust in some ways to make it work better with Simplicity and with the blockchain.</p>"},{"location":"simplicityhl-reference/type/#boolean-type","title":"Boolean Type","text":"Type Description Values <code>bool</code> Boolean <code>false</code>, <code>true</code> <p>Values of type <code>bool</code> are truth values, which are either <code>true</code> or <code>false</code>.</p>"},{"location":"simplicityhl-reference/type/#integer-types","title":"Integer Types","text":"Type Description Values <code>u1</code> 1-bit integer <code>0</code>, <code>1</code> <code>u2</code> 2-bit integer <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code> <code>u4</code> 4-bit integer <code>0</code>, <code>1</code>, \u2026, <code>15</code> <code>u8</code> 8-bit integer <code>0</code>, <code>1</code>, \u2026, <code>255</code> <code>u16</code> 16-bit integer <code>0</code>, <code>1</code>, \u2026, <code>65535</code> <code>u32</code> 32-bit integer <code>0</code>, <code>1</code>, \u2026, <code>4294967295</code> <code>u64</code> 64-bit integer <code>0</code>, <code>1</code>, \u2026, <code>18446744073709551615</code> <code>u128</code> 128-bit integer <code>0</code>, <code>1</code>, \u2026, <code>340282366920938463463374607431768211455</code> <code>u256</code> 256-bit integer <code>0</code>, <code>1</code>, \u2026, 2<sup>256</sup> - 1[^u256max] <p>Unsigned integers range from 1 bit to 256 bits. <code>u8</code> to <code>u128</code> are also supported in Rust. <code>u1</code>, <code>u2</code>, <code>u4</code> and <code>u256</code> are new to SimplicityHL. Integer values can be written in decimal notation <code>123456</code>, binary notation[^bin] <code>0b10101010</code> or hexadecimal notation[^hex] <code>0xdeadbeef</code>. There are no signed integers.</p> <p>[^u256max]: The maximal value of type <code>u256</code> is <code>115792089237316195423570985008687907853269984665640564039457584007913129639935</code>. [^bin]: The number of bits must be equal to the bit width of the type. [^hex]: The number of hex digits must correspond to the bit width of the type.</p>"},{"location":"simplicityhl-reference/type/#tuple-types","title":"Tuple Types","text":"Type Description Values <code>()</code> 0-tuple <code>()</code> <code>(A)</code> 1-tuple <code>(a0,)</code>, <code>(a1,)</code>, \u2026 <code>(A, B)</code> 2-tuple <code>(a0, b0)</code>, <code>(a1, b1)</code>, <code>(a2, b2)</code>, <code>(a3, b3)</code>, \u2026 \u2026 \u2026 \u2026 <code>(A, B, \u2026)</code> n-tuple <code>(a0, b0, \u2026)</code>, \u2026 <p>Tuples work just like in Rust.</p> <p>The empty tuple <code>()</code> contains no information. It is also called the \"unit\". It is mostly used as the return type of functions that don't return anything.</p> <p>Singletons <code>(a0,)</code> must be written with an extra comma <code>,</code> to differentiate them from function calls.</p> <p>Bigger tuples <code>(a0, b0, \u2026)</code> work like in pretty much any other programming language. Each tuple type <code>(A1, A2, \u2026, AN)</code> defines a sequence <code>A1</code>, <code>A2</code>, \u2026, <code>AN</code> of types. Values of that type must mirror the sequence of types: A tuple value <code>(a1, a2, \u2026, aN)</code> consists of a sequence <code>a1</code>, <code>a2</code>, \u2026, <code>aN</code> of values, where <code>a1</code> is of type <code>A1</code>, <code>a2</code> is of type <code>A2</code>, and so on. Tuples are always finite in length.</p> <p>Tuples are different from arrays: Each element of a tuple can have a different type. Each element of an array must have the same type.</p>"},{"location":"simplicityhl-reference/type/#array-types","title":"Array Types","text":"Type Description Values <code>[A; 0]</code> 0-array <code>[]</code> <code>[A; 1]</code> 1-array <code>[a0]</code>, <code>[a1]</code>, \u2026 <code>[A; 2]</code> 2-array <code>[a0, a1]</code>, <code>[a2, a3]</code>, <code>[a4, a5]</code>, <code>[a6, a7]</code>, \u2026 \u2026 \u2026 \u2026 <code>[A; N]</code> n-array <code>[a0, \u2026, aN]</code>, \u2026 <p>Arrays work just like in Rust.</p> <p>The empty array <code>[]</code> is basically useless, but I included it for completeness.</p> <p>Arrays <code>[a0, \u2026, aN]</code> work like in pretty much any other programming language. Each array type <code>[A; N]</code> defines an element type <code>A</code> and a length <code>N</code>. An array value <code>[a0, \u2026, aN]</code> of that type consists of <code>N</code> many elements <code>a0</code>, \u2026, <code>aN</code> that are each of type <code>A</code>. Arrays are always of finite length.</p> <p>Arrays are different from tuples: Each element of an array must have the same type. Each element of a tuple can have a different type.</p>"},{"location":"simplicityhl-reference/type/#list-types","title":"List Types","text":"Type Description Values <code>List&lt;A, 2&gt;</code> &lt;2-list <code>list![]</code>, <code>list![a1]</code> <code>List&lt;A, 4&gt;</code> &lt;4-list <code>list![]</code>, \u2026, <code>list![a1, a2, a3]</code> <code>List&lt;A, 8&gt;</code> &lt;8-list <code>list![]</code>, \u2026, <code>list![a1, \u2026, a7]</code> <code>List&lt;A, 16&gt;</code> &lt;16-list <code>list![]</code>, \u2026, <code>list![a1, \u2026, a15]</code> <code>List&lt;A, 32&gt;</code> &lt;32-list <code>list![]</code>, \u2026, <code>list![a1, \u2026, a31]</code> <code>List&lt;A, 64&gt;</code> &lt;64-list <code>list![]</code>, \u2026, <code>list![a1, \u2026, a62]</code> <code>List&lt;A, 128&gt;</code> &lt;128-list <code>list![]</code>, \u2026, <code>list![a1, \u2026, a127]</code> <code>List&lt;A, 256&gt;</code> &lt;256-list <code>list![]</code>, \u2026, <code>list![a1, \u2026, a255]</code> <code>List&lt;A, 512&gt;</code> &lt;512-list <code>list![]</code>, \u2026, <code>list![a1, \u2026, a511]</code> \u2026 \u2026 \u2026 <code>List&lt;A, 2^N&gt;</code> &lt;2^N-list <code>list![]</code>, \u2026, <code>list![a1, \u2026, a_{2^N - 1}]</code> <p>Lists hold a variable number of elements of the same type. This is similar to Rust vectors, but SimplicityHL doesn't have a heap. In SimplicityHL, lists exist on the stack, which is why the maximum list length is bounded.</p> <p>&lt;2-lists hold fewer than 2 elements, so zero or one element. &lt;4-lists hold fewer than 4 elements, so zero to three elements. &lt;8-lists hold fewer than 8 elements, so zero to seven elements. And so on. For technical reasons, the list bound is always a power of two. The bound 1 is not supported, because it would only allow empty lists, which is useless.</p> <p>Lists are different from arrays: List values hold a variable number of elements. Array values hold a fixed number of elements.</p> <p>On the blockchain, you pay for every byte that you use. If you use an array, then you pay for every single element. For example, values of type <code>[u8; 512]</code> cost roughly as much as 512 many <code>u8</code> values. However, if you use a list, then you only pay for the elements that you actually use. For example, the type <code>List&lt;u8, 512&gt;</code> allows for up to 511 elements. If you only use three elements <code>list![1, 2, 3]</code>, then you pay for exactly three elements. You don't pay for the remaining 508 unused elements.</p>"},{"location":"simplicityhl-reference/type/#option-types","title":"Option Types","text":"Type Values <code>Option&lt;A&gt;</code> <code>None</code>, <code>Some(a0)</code>, <code>Some(a1)</code>, \u2026 <p>Options represent values that might not be present. They work just like in Rust.</p> <p>An option type is generic over a type <code>A</code>. The value <code>None</code> is empty. The value <code>Some(a)</code> contains an inner value <code>a</code> of type <code>A</code>.</p> <p>In Rust, we implement options as follows.</p> <pre><code>enum Option&lt;A&gt; {\n    None,\n    Some(A),\n}\n</code></pre>"},{"location":"simplicityhl-reference/type/#either-types","title":"Either Types","text":"Type Values <code>Either&lt;A, B&gt;</code> <code>Left(a0)</code>, <code>Left(a1)</code>, \u2026, <code>Right(b0)</code>, <code>Right(b1)</code>, \u2026 <p>Sum types represent values that are of some \"left\" type in some cases and that are of another \"right\" type in other cases. They work just like in the either crate. The Result type from Rust is very similar, too.</p> <p>A sum type is generic over two types, <code>A</code> and <code>B</code>. The value <code>Left(a)</code> contains an inner value <code>a</code> of type <code>A</code>. The value <code>Right(b)</code> contains an inner value <code>b</code> of type <code>B</code>.</p> <p>In Rust, we implement sum types as follows.</p> <pre><code>enum Either&lt;A, B&gt; {\n    Left(A),\n    Right(B),\n}\n</code></pre>"},{"location":"simplicityhl-reference/type_alias/","title":"Type Aliases","text":"<p>SimplicityHL currently doesn't support Rust-like <code>struct</code>s for organizing data.</p> <pre><code>struct User {\n  active: bool,\n  id: u256,\n  sign_in_count: u64,\n}\n</code></pre> <p>SimplicityHL programmers have to handle long tuples of unlabeled data, which can get messy.</p> <pre><code>(bool, u256, u64)\n</code></pre> <p>To help with the situation, programmers can define custom type aliases. Aliases define a new name for an existing type. In contrast, <code>struct</code>s define an entirely new type, so aliases are different from <code>struct</code>s. However, aliases still help us to make the code more readable.</p> <pre><code>type User = (bool, u256, u64);\n</code></pre> <p>There is also a list of builtin type aliases. These aliases can be used without defining them.</p> Builtin Alias Definition <code>Amount1</code> <code>Either&lt;(u1, u256), u64&gt;</code> <code>Asset1</code> <code>Either&lt;(u1, u256), u256&gt;</code> <code>Confidential1</code> <code>(u1, u256)</code> <code>Ctx8</code> <code>(List&lt;u8, 64&gt;, (u64, u256))</code> <code>Distance</code> <code>u16</code> <code>Duration</code> <code>u16</code> <code>ExplicitAmount</code> <code>u256</code> <code>ExplicitAsset</code> <code>u256</code> <code>ExplicitNonce</code> <code>u256</code> <code>Fe</code> <code>u256</code> <code>Ge</code> <code>(u256, u256)</code> <code>Gej</code> <code>((u256, u256), u256)</code> <code>Height</code> <code>u32</code> <code>Lock</code> <code>u32</code> <code>Message</code> <code>u256</code> <code>Message64</code> <code>[u8; 64]</code> <code>Nonce</code> <code>Either&lt;(u1, u256), u256&gt;</code> <code>Outpoint</code> <code>(u256, u32)</code> <code>Point</code> <code>(u1, u256)</code> <code>Pubkey</code> <code>u256</code> <code>Scalar</code> <code>u256</code> <code>Signature</code> <code>[u8; 64]</code> <code>Time</code> <code>u32</code> <code>TokenAmount1</code> <code>Either&lt;(u1, u256), u64&gt;</code>"},{"location":"simplicityhl-reference/type_casting/","title":"Casting","text":"<p>A SimplicityHL type can be cast into another SimplicityHL type if both types share the same structure. The structure of a type has to do with how the type is implemented on the Simplicity \"processor\". I will spare you the boring details.</p> <p>Below is a table of types that can be cast into each other.</p> Type Casts To (And Back) <code>bool</code> <code>Either&lt;(), ()&gt;</code> <code>Option&lt;A&gt;</code> <code>Either&lt;(), A&gt;</code> <code>u1</code> <code>bool</code> <code>u2</code> <code>(u1, u1)</code> <code>u4</code> <code>(u2, u2)</code> <code>u8</code> <code>(u4, u4)</code> <code>u16</code> <code>(u8, u8)</code> <code>u32</code> <code>(u16, u16)</code> <code>u64</code> <code>(u32, u32)</code> <code>u128</code> <code>(u64, u64)</code> <code>u256</code> <code>(u128, u128)</code> <code>(A)</code> <code>A</code> <code>(A, B, C)</code> <code>(A, (B, C))</code> <code>(A, B, C, D)</code> <code>((A, B), (C, D))</code> \u2026 \u2026 <code>[A; 0]</code> <code>()</code> <code>[A; 1]</code> <code>A</code> <code>[A; 2]</code> <code>(A, A)</code> <code>[A; 3]</code> <code>(A, (A, A))</code> <code>[A; 4]</code> <code>((A, A), (A, A))</code> \u2026 \u2026 <code>List&lt;A, 2&gt;</code> <code>Option&lt;A&gt;</code> <code>List&lt;A, 4&gt;</code> <code>(Option&lt;[A; 2]&gt;, List&lt;A, 2&gt;)</code> <code>List&lt;A, 8&gt;</code> <code>(Option&lt;[A; 4]&gt;, List&lt;A, 4&gt;)</code> <code>List&lt;A, 16&gt;</code> <code>(Option&lt;[A; 8]&gt;, List&lt;A, 8&gt;)</code> <code>List&lt;A, 32&gt;</code> <code>(Option&lt;[A; 16]&gt;, List&lt;A, 16&gt;)</code> <code>List&lt;A, 64&gt;</code> <code>(Option&lt;[A; 32]&gt;, List&lt;A, 32&gt;)</code> <code>List&lt;A, 128&gt;</code> <code>(Option&lt;[A; 64]&gt;, List&lt;A, 64&gt;)</code> <code>List&lt;A, 256&gt;</code> <code>(Option&lt;[A; 128]&gt;, List&lt;A, 128&gt;)</code> <code>List&lt;A, 512&gt;</code> <code>(Option&lt;[A; 256]&gt;, List&lt;A, 256&gt;)</code> \u2026 \u2026"},{"location":"simplicityhl-reference/type_casting/#casting-rules","title":"Casting Rules","text":"<p>Type <code>A</code> can be cast into itself (reflexivity).</p> <p>If type <code>A</code> can be cast into type <code>B</code>, then type <code>B</code> can be cast into type <code>A</code> (symmetry).</p> <p>If type <code>A</code> can be cast into type <code>B</code> and type <code>B</code> can be cast into type <code>C</code>, then type <code>A</code> can be cast into type <code>C</code> (transitivity).</p>"},{"location":"simplicityhl-reference/type_casting/#casting-expression","title":"Casting Expression","text":"<p>All casting in SimplicityHL happens explicitly through a casting expression.</p> <pre><code>&lt;Input&gt;::into(input)\n</code></pre> <p>The above expression casts the value <code>input</code> of type <code>Input</code> into some output type. The input type of the cast is explicit while the output type is implicit.</p> <p>In SimplicityHL, the output type of every expression is known.</p> <pre><code>let x: u32 = 1;\n</code></pre> <p>In the above example, the meaning of the expression <code>1</code> is clear because of the type <code>u32</code> of variable <code>x</code>. Here, <code>1</code> means a string of 31 zeroes and 1 one. In other contexts, <code>1</code> could mean something different, like a string of 255 zeroes and 1 one.</p> <p>The SimplicityHL compiler knows the type of the outermost expression, and it tries to infer the types of inner expressions based on that. When it comes to casting expressions, the compiler has no idea about the input type of the cast. The programmer needs to supply this information by annotating the cast with its input type.</p> <pre><code>let x: u32 = &lt;(u16, u16)&gt;::into((0, 1));\n</code></pre> <p>In the above example, we cast the tuple <code>(0, 1)</code> of type <code>(u16, u16)</code> into type <code>u32</code>. Feel free to consult the table above to verify that this is a valid cast.</p>"},{"location":"use-cases/","title":"Use Cases Overview","text":""},{"location":"use-cases/cross-chain-atomic-swaps/","title":"Cross-Chain Atomic Swaps","text":""},{"location":"use-cases/crowdfunding/","title":"Crowdfunding Contracts","text":""},{"location":"use-cases/discreet-log-contracts/","title":"Discreet Log Contracts","text":""},{"location":"use-cases/financial-contracts/","title":"Financial Contracts","text":""},{"location":"use-cases/insurance-contracts/","title":"Insurance Contracts","text":""},{"location":"use-cases/unchained/","title":"Simplicity Unchained","text":""},{"location":"use-cases/vaults/","title":"Vaults","text":""}]}